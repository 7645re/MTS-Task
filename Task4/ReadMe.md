![image](https://user-images.githubusercontent.com/89273037/168437590-b6b3ce16-106a-43a1-b60d-60e3aeeef2d9.png)

# Сортировка подсчетом
При сортировке массива из 1 000 000 000 чисел занимается ~3815МБ памяти(просто для хранения массива в памяти) и массив сортируется за 4465 миллисекунд.
Использовал сортировку подсчетом, ее сложность по времени O(n + k), ее сложность по памяти O(n + k).
Выбрал этот алгоритм сортировки, потому что у нас достаточно не большой промежуток возможных чисел в массиве.

# Сортировка подсчетом + Скользящее окно
Я решил использовать алгоритм, который будет совмешать шаблон "Скользящее окно" и сортировку подсчетом.
Выражение: Xn-sortFactor<=Xn+j | n,j - индексы
=> неотсортированные числа относительно Xn будут находиться в промежутке [array[i]-sortFactor;array[i]]
мы можем облегчить память храня счетчики только этих чисел

sortFactor = 6

11, [5, 6, 10], 16, [11, 13, 15, 12] 20 ...
По запросу потребителя будут сбрасываться части потока чисел, которые в квадратных скобках + элемент подсчета (в данном случае 11 и 16), по очереди и этот 
небольшой участок будет сортироваться с помощью сортировки подсчетом

```
       :\     /;               _
      ;  \___/  ;             ; ;
     ,:-"'   `"-:.            / ;
_   /,---.   ,---.\   _     _; /
_:>((  |  ) (  |  ))<:_ ,-""_,"     
    \`````   `````/""""",-""           
     '-.._ v _..-'      )               
       / ___   ____,..  \
      / /   | |   | ( \. \
     / /    | |    | |  \ \
     `"     `"     `"    `"
```
