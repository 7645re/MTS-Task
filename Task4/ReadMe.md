![image](https://user-images.githubusercontent.com/89273037/168437590-b6b3ce16-106a-43a1-b60d-60e3aeeef2d9.png)

При сортировке массива из 1 000 000 000 чисел занимается ~3815МБ памяти и массив сортируется за 4465 миллисекунд.
Использовал сортировку подсчетом, ее сложность по времени O(n + k), ее сложность по памяти O(n + k).
Выбрал этот алгоритм сортировки, потому что у нас достаточно не большой промежуток возможных чисел в массиве.
Что по поводу sortFactor, я разобрался для чего он, но не совсем понял как реализовать решением с ним.
Выражение: Xn-sortFactor<=Xn+j | n,j - индексы
=> неотсортированные числа относительно Xn будут находиться в промежутке [array[i]-sortFactor;array[i]]
мы можем облегчить память храня счетчики только этих чисел
sortFactor = 6

13, [1, 5, 2, 3, 4, 7], 16, [11, 13, 15, 12] 20 ...
По запросу потребителя будут сбрасываться части потока чисел, которые в квадратных скобках, по очереди и этот 
небольшой участок будет сортироваться с помощью сортировки подсчетом
у меня произошел ступор, как мне это оптимизировать не храня в массиве с количеством вхождений чисел.

Пример: [1, 5, 2, 3, 4, 7] -> [0,1,1,1,1,0,0,1] => у  нас остаются места в массиве, которые просто так занимают память
Пример: [100, 30, 2000] -> [... , 1, ... , 1, ... 1] => и как тогда получается, что мы оптимизируем хранимые счетчики
если вместо них просто нули, которые тоже занимают память
```
       :\     /;               _
      ;  \___/  ;             ; ;
     ,:-"'   `"-:.            / ;
_   /,---.   ,---.\   _     _; /
_:>((  |  ) (  |  ))<:_ ,-""_,"         Я правда старался решить, но почему-то не получилось :)
    \`````   `````/""""",-""
     '-.._ v _..-'      )
       / ___   ____,..  \
      / /   | |   | ( \. \
     / /    | |    | |  \ \
     `"     `"     `"    `"
```
